(* quite naive implementation *)
let rec dikjstra ( +. ) ( < ) q edge d =
  match q with
  | [] -> ()
  | u :: q ->
      let u, q = 
        List.fold_left (fun (u, q') u' ->
          if d.(u) < d.(u') then (u, u' :: q')
          else (u', u :: q')) (u, []) q in
      List.iter (fun (v, c) ->
        if c +. d.(u) < d.(v) then
          d.(v) <- c +. d.(u)) (edge u);
      dikjstra ( +. ) ( < ) q edge d


(* sample code *)
let d = Array.make 6 infinity;;
d.(0) <- 0.;;
dikjstra ( +. ) ( < ) [0; 1; 2; 3; 4; 5] (function
  | 0 -> [ (1, 7.); (2, 9.); (5, 14.) ]
  | 1 -> [ (0, 7.); (2, 10.); (3, 15.) ]
  | 2 -> [ (0, 9.); (1, 10.); (3, 11.); (5, 2.) ]
  | 3 -> [ (1, 15.); (2, 11.); (4, 6.) ]
  | 4 -> [ (3, 6.); (5, 9.) ]
  | 5 -> [ (0, 14.); (2, 2.); (4, 9.) ]) d;;
d;;

let d = Array.make 6 (infinity, []);;
d.(0) <- (0., []);;
dikjstra
  (fun (c, r) (c', rs) -> (c +. c', r :: rs))
  (fun (c, _) (c', _) -> c < c')
  [0; 1; 2; 3; 4; 5]
  (function
    | 0 -> [ (1, (7., "0->1")); (2, (9., "0->2")); (5, (14., "0->5")) ]
    | 1 -> [ (0, (7., "1->0")); (2, (10., "1->2")); (3, (15., "1->3")) ]
    | 2 -> [ (0, (9., "2->0")); (1, (10., "2->1")); (3, (11., "2->3"));
        (5, (2., "2->5")) ]
    | 3 -> [ (1, (15., "3->1")); (2, (11., "3->2")); (4, (6., "3->4")) ]
    | 4 -> [ (3, (6., "4->3")); (5, (9., "4->5")) ]
    | 5 -> [ (0, (14., "5->0")); (2, (2., "5->2")); (4, (9., "5->4")) ]) d;;
d;;

